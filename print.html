<!DOCTYPE HTML>
<html lang="en" class="sidebar-visible no-js light">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Tokio: Rust's Asynchronous Runtime</title>
        
        <meta name="robots" content="noindex" />
        

        <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff" />

        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link href="https://fonts.googleapis.com/css?family=Open+Sans:300italic,400italic,600italic,700italic,800italic,400,300,600,700,800" rel="stylesheet" type="text/css">
        <link href="https://fonts.googleapis.com/css?family=Source+Code+Pro:500" rel="stylesheet" type="text/css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->
        

        
    </head>
    <body>
        <!-- Provide site root to javascript -->
        <script type="text/javascript">
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "light" : "light";
        </script>

        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script type="text/javascript">
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script type="text/javascript">
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            var html = document.querySelector('html');
            html.classList.remove('no-js')
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add('js');
        </script>

        <!-- Hide / unhide sidebar before it is displayed -->
        <script type="text/javascript">
            var html = document.querySelector('html');
            var sidebar = 'hidden';
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            }
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <div id="sidebar-scrollbox" class="sidebar-scrollbox">
                <ol class="chapter"><li class="expanded "><a href="overview.html"><strong aria-hidden="true">1.</strong> Overview</a></li><li class="expanded "><a href="getting-started/hello-world.html"><strong aria-hidden="true">2.</strong> Getting started</a></li><li><ol class="section"><li class="expanded "><a href="getting-started/hello-world.html"><strong aria-hidden="true">2.1.</strong> Hello World!</a></li><li class="expanded "><a href="getting-started/futures.html"><strong aria-hidden="true">2.2.</strong> Futures</a></li><li class="expanded "><a href="getting-started/runtime.html"><strong aria-hidden="true">2.3.</strong> Runtime</a></li><li class="expanded "><a href="getting-started/echo.html"><strong aria-hidden="true">2.4.</strong> Example: An Echo Server</a></li></ol></li></ol>
            </div>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle"></div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                
                <div id="menu-bar" class="menu-bar">
                    <div id="menu-bar-sticky-container">
                        <div class="left-buttons">
                            <button id="sidebar-toggle" class="icon-button" type="button" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                                <i class="fa fa-bars"></i>
                            </button>
                            <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                                <i class="fa fa-paint-brush"></i>
                            </button>
                            <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                                <li role="none"><button role="menuitem" class="theme" id="light">Light (default)</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                                <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                            </ul>
                            
                            <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                                <i class="fa fa-search"></i>
                            </button>
                            
                        </div>

                        <h1 class="menu-title">Tokio: Rust's Asynchronous Runtime</h1>

                        <div class="right-buttons">
                            <a href="print.html" title="Print this book" aria-label="Print this book">
                                <i id="print-button" class="fa fa-print"></i>
                            </a>
                            
                            <a href="https://github.com/tokio-rs/tokio" title="Git repository" aria-label="Git repository">
                                <i id="git-repository-button" class="fa fa-github"></i>
                            </a>
                            
                        </div>
                    </div>
                </div>

                
                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" name="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>
                

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script type="text/javascript">
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <p><img src="./static/img/Tokio_Horizontal_Large.png" alt="Tokio logo" /></p>
<p>Tokio allows developers to write asynchronous programs in the Rust programming
language. Instead of synchronously waiting for long-running operations (like reading
a file or waiting for a timer to complete) before moving on to the next thing,
Tokio allows developers to write programs where execution continues while the
long-running operations are in progress.</p>
<p>More specifically, Tokio is an event-driven, non-blocking I/O platform
for writing asynchronous applications with Rust. At a high level, it
provides a few major components:</p>
<ul>
<li>A multithreaded, work-stealing based task <a href="https://tokio-rs.github.io/tokio/tokio/runtime/index.html">scheduler</a>.</li>
<li>A <a href="https://docs.rs/tokio/0.1/tokio/reactor/index.html">reactor</a> backed by the operating system's event queue (epoll, kqueue,
IOCP, etc...).</li>
<li>Asynchronous <a href="https://docs.rs/tokio/0.1/tokio/net/index.html">TCP and UDP</a> sockets.</li>
</ul>
<p>These components provide the runtime components necessary for building
an asynchronous application.</p>
<h1><a class="header" href="#fast" id="fast">Fast</a></h1>
<p>Tokio is built on the Rust programming language, which is itself very
fast. Applications built with Tokio will get those same benefits. Tokio's design
is also geared towards enabling applications to be as fast as possible.</p>
<h2><a class="header" href="#zero-cost-abstractions" id="zero-cost-abstractions">Zero-cost abstractions</a></h2>
<p>Tokio is built around [futures]. Futures aren't a new idea, but the way Tokio
uses them is [unique][poll]. Unlike futures from other languages, Tokio's
futures compile down to a state machine. There is no added overhead from
synchronization, allocation, or other costs common with future implementations.</p>
<p>Note that providing zero-cost abstractions does not mean that Tokio itself has
no cost. It means that using Tokio results in an end product with equivalent
overhead to not using Tokio.</p>
<p>[poll]: {{&lt; ref &quot;/docs/getting-started/futures.md&quot; &gt;}}#poll-based-futures
[futures]: {{&lt; ref &quot;/docs/getting-started/futures.md&quot; &gt;}}</p>
<h2><a class="header" href="#concurrency" id="concurrency">Concurrency</a></h2>
<p>Out of the box, Tokio provides a multi-threaded, <a href="https://en.wikipedia.org/wiki/Work_stealing">work-stealing</a>, scheduler. So,
when you start the Tokio runtime, you are already using all of your computer's
CPU cores.</p>
<p>Modern computers increase their performance by adding cores, so being able to
utilize many cores is critical for writing fast applications.</p>
<h2><a class="header" href="#non-blocking-io" id="non-blocking-io">Non-blocking I/O</a></h2>
<p>When hitting the network, Tokio will use the most efficient system available to
the operating system. On Linux this means <a href="http://man7.org/linux/man-pages/man7/epoll.7.html">epoll</a>, bsd platforms provide <a href="https://www.freebsd.org/cgi/man.cgi?query=kqueue&amp;sektion=2">kqueue</a>,
and Windows has <a href="https://docs.microsoft.com/en-us/windows/desktop/fileio/i-o-completion-ports">I/O completion ports</a>.</p>
<p>This allows multiplexing many sockets on a single thread and receiving
operating system notifications in batches, thus reducing system calls. All this
leads to less overhead for the application.</p>
<h1><a class="header" href="#reliable" id="reliable">Reliable</a></h1>
<p>While Tokio cannot prevent all bugs, it is designed to minimize them. It does
this by providing APIs that are hard to misuse. At the end of the day, you can
ship applications to production with confidence.</p>
<h2><a class="header" href="#ownership-and-type-system" id="ownership-and-type-system">Ownership and type system</a></h2>
<p>Rust's ownership model and type system enables implementing system level
applications without the fear of memory unsafety. It prevents classic bugs
such as accessing uninitialized memory and use after free. It does this without
adding any run-time overhead.</p>
<p>Further, APIs are able to leverage the type system to provide hard to misuse
APIs. For example, <code>Mutex</code> does not require the user to explicitly unlock.</p>
<h2><a class="header" href="#backpressure" id="backpressure">Backpressure</a></h2>
<p>In push based systems, when a producer produces data faster than the consumer
can process, data will start backing up. Pending data is stored in memory.
Unless the producer stops producing, the system will eventually run out of
memory and crash. The ability for a consumer to inform the producer to slow down
is backpressure.</p>
<p>Because Tokio uses a [poll] based model, the problem mostly just goes away.
Producers are lazy by default. They will not produce any data unless the
consumer asks them to. This is built into Tokio's foundation.</p>
<h2><a class="header" href="#cancellation" id="cancellation">Cancellation</a></h2>
<p>Because of Tokio's [poll] based model, computations do no work unless they are
polled. Dependents of that computation hold a [future][futures] representing the
result of that computation. If the result is no longer needed, the future is
dropped. At this point, the computation will no longer be polled and thus
perform no more work.</p>
<p>Thanks to Rust's ownership model, the computation is able to implement <code>drop</code>
handles to detect the future being dropped. This allows it to perform any
necessary cleanup work.</p>
<h1><a class="header" href="#lightweight" id="lightweight">Lightweight</a></h1>
<p>Tokio scales well without adding overhead to the application, allowing it to
thrive in resource constrained environments.</p>
<h2><a class="header" href="#no-garbage-collector" id="no-garbage-collector">No garbage collector</a></h2>
<p>Because Tokio is built on Rust, the compiled executable includes minimal
language run-time. The end product is similar to what C++ would produce. This
means, no garbage collector, no virtual machine, no JIT compilation, and no
stack manipulation. Write your server applications without fear of
<a href="https://en.wikipedia.org/wiki/Garbage_collection_(computer_science)#Disadvantages">stop-the-world</a> pauses.</p>
<p>It is possible to use Tokio without incurring any runtime allocations, making it
a good fit for <a href="https://en.wikipedia.org/wiki/Real-time_computing">real-time</a> use cases.</p>
<h2><a class="header" href="#modular" id="modular">Modular</a></h2>
<p>While Tokio provides a lot out of the box, it is all organized very modularly.
Each component lives in a separate library. If needed, applications may opt to
pick and choose the needed components and avoid pulling in the rest.</p>
<p>Tokio leverages <a href="https://github.com/tokio-rs/mio"><code>mio</code></a> for the system event queue and <a href="https://docs.rs/futures/*/futures/"><code>futures</code></a> for defining
tasks.  Tokio implements <a href="https://tokio.rs/blog/2018-08-async-await/">async</a> syntax to improve readability of futures.
<a href="https://crates.io/crates/tokio/reverse_dependencies">Many</a> libraries are implemented using Tokio, including <a href="https://hyper.rs/guides/"><code>hyper</code></a> and <a href="https://actix.rs/book/actix/"><code>actix</code></a>.</p>
<h1><a class="header" href="#example" id="example">Example</a></h1>
<p>A basic TCP echo server with Tokio:</p>
<pre><pre class="playpen"><code class="language-rust edition2018">use tokio::net::TcpListener;
use tokio::prelude::*;

#[tokio::main]
async fn main() {
    // Bind the server's socket.
    let addr = &quot;127.0.0.1:12345&quot;;
    let mut incoming = TcpListener::bind(&amp;addr)
        .await
        .expect(&quot;unable to bind TCP listener&quot;)
        .incoming();

    // Pull out a stream of sockets for incoming connections
    while let Some(conn) = incoming.next().await {
        match conn {
            Err(e) =&gt; eprintln!(&quot;accept failed = {:?}&quot;, e),
            Ok(mut sock) =&gt; {
                // Spawn the future that echos the data and returns how
                // many bytes were copied as a concurrent task.
                tokio::spawn(async move {
                    // Split up the reading and writing parts of the
                    // socket.
                    let (mut reader, mut writer) = sock.split();

                    match reader.copy(&amp;mut writer).await {
                        Ok(amt) =&gt; {
                            println!(&quot;wrote {:} bytes&quot;, amt);
                        }
                        Err(err) =&gt; {
                            eprintln!(&quot;IO error {:?}&quot;, err);
                        }
                    }
                });
            }
        }
    }
}
</code></pre></pre>
<p>More examples can be found <a href="https://github.com/tokio-rs/tokio/tree/master/examples">here</a>.</p>
<h1><a class="header" href="#hello-world" id="hello-world">Hello World!</a></h1>
<p>To kick off our tour of Tokio, we will start with the obligatory &quot;hello world&quot;
example. This program will create a TCP stream and write &quot;hello, world!&quot; to the stream.
The difference between this and a Rust program that writes to a TCP stream without Tokio
is that this program won't block program execution when the stream is created or when
our &quot;hello, world!&quot; message is written to the stream.</p>
<p>Before we begin you should have a very basic understanding of how TCP streams work. Having
an understanding of Rust’s <a href="https://doc.rust-lang.org/std/net/struct.TcpStream.html">standard library implementation</a>
is also helpful.</p>
<p>Let's get started.</p>
<p>First, generate a new crate.</p>
<pre><code class="language-bash">$ cargo new hello-world
$ cd hello-world
</code></pre>
<p>Next, add the necessary dependencies in <code>Cargo.toml</code>:</p>
<pre><code class="language-toml">[dependencies]
tokio = &quot;0.2.0-alpha&quot;
</code></pre>
<p>We are going to use Tokio's own <a href="https://docs.rs/tokio/*/tokio/net/index.html"><code>net</code></a> module. This module provides the same
abstractions over networking and I/O-operations as the corresponding module in <code>std</code>
with a small difference: all actions are performed asynchronously.</p>
<h1><a class="header" href="#creating-the-stream" id="creating-the-stream">Creating the stream</a></h1>
<p>The first step is to create the <code>TcpStream</code>. We use the <code>TcpStream</code> implementation
provided by Tokio.</p>
<pre><pre class="playpen"><code class="language-rust edition2018">use tokio::net::TcpStream;

fn main() {
    let addr = &quot;127.0.0.1:6142&quot;;
    let client = TcpStream::connect(addr);

    // Following snippets come here...
}
</code></pre></pre>
<p>Next, we'll add some to the <code>client</code> <code>TcpStream</code>. This asynchronous task now creates
the stream and then yields it once it's been created for additional processing.</p>
<pre><pre class="playpen"><code class="language-rust edition2018"><span class="boring">use tokio::net::TcpStream;
</span>
<span class="boring">fn main() {
</span>let addr = &quot;127.0.0.1:6142&quot;;
let client = TcpStream::connect(addr);

let future = async move {
  // TcpStream::connect future has an Output type of io::Result&lt;TcpStream&gt;
  match client.await {
    Ok(_stream) =&gt; {
      println!(&quot;created stream&quot;);

      // Process stream here.
    }
    Err(err) =&gt; {
      // In our example, we are only going to log the error to STDOUT.
      println!(&quot;connection error = {:?}&quot;, err);
    }
  };
};
<span class="boring">}
</span></code></pre></pre>
<p>The call to <code>TcpStream::connect</code> returns a <a href="https://docs.rs/futures-preview/*/futures-preview/future/trait.Future.html"><code>Future</code></a> of the created TCP stream.
We'll learn more about <a href="getting-started//docs/getting-started/futures/"><code>Futures</code></a> later in the guide, but for now you can think of
a <a href="https://docs.rs/futures-preview/*/futures-preview/future/trait.Future.html"><code>Future</code></a> as a value that represents something that will eventually happen in the
future (in this case the stream will be created). This means that <code>TcpStream::connect</code> does
not wait for the stream to be created before it returns. Rather, it returns immediately
with a value representing the work of creating a TCP stream.</p>
<p>Note the <code>async</code> block that follows. Like the <code>TcpStream::connect</code> future,
the contents of the <code>async</code> block are not executed immediately.
Instead, they are stored in an object whose result can be computed later.
Inside the <code>async</code> block we can <code>await</code> the created future, so that any code that follows
is executed with the result of the <code>await</code>-ed <a href="https://docs.rs/futures-preview/*/futures-preview/future/trait.Future.html"><code>Future</code></a>'s computation.</p>
<p>We will be digging more into futures (and the related concepts of streams and sinks) later on.</p>
<p>Next, we will process the stream.</p>
<h1><a class="header" href="#writing-data" id="writing-data">Writing data</a></h1>
<p>Our goal is to write <code>&quot;hello world\n&quot;</code> to the stream.</p>
<p>Going back to the <code>async</code> block in the previous example:</p>
<pre><pre class="playpen"><code class="language-rust edition2018">use tokio::io::AsyncWriteExt;
use tokio::net::TcpStream;

fn main() {
    let addr = &quot;127.0.0.1:6142&quot;;
    let client = TcpStream::connect(addr);

    let future = async move {
        if let Ok(mut stream) = client.await {
            println!(&quot;created stream&quot;);

            let result = stream.write_all(b&quot;hello world\n&quot;).await;

            println!(&quot;wrote to stream; success={:?}&quot;, result.is_ok());
        }
    };
}
</code></pre></pre>
<p>The [<code>AsyncWriteExt::write_all</code>] trait method takes <code>stream</code> by mutable reference,
<a href="https://docs.rs/futures-preview/*/futures-preview/future/trait.Future.html"><code>Future</code></a> that completes once the entire message has been written to the
stream. In our example, we <code>await</code> for the completion of said future and just
write a message to <code>STDOUT</code> indicating that the write has completed.</p>
<p>Note that <code>result</code> is a <code>Result</code> that contains the original stream (compare to
<code>and_then</code>, which passes the stream without the <code>Result</code> wrapper). This allows us
to sequence additional reads or writes to the same stream. However, we have
nothing more to do, so we just drop the stream, which automatically closes it.</p>
<h1><a class="header" href="#running-the-client-task" id="running-the-client-task">Running the client task</a></h1>
<p>So far we have a <code>Future</code> representing the work to be done by our program, but we
have not actually run it. We need a way to 'spawn' that work. We need an executor.</p>
<p>Executors are responsible for scheduling asynchronous tasks, driving them to
completion. There are a number of executor implementations to choose from, each have
different pros and cons. In this example, we will use the default executor of the
<a href="https://docs.rs/tokio/*/tokio/runtime/index.html">Tokio runtime</a>.</p>
<pre><pre class="playpen"><code class="language-rust edition2018">use tokio::io::AsyncWriteExt;
use tokio::net::TcpStream;

#[tokio::main]
async fn main() {
    let addr = &quot;127.0.0.1:6142&quot;;
    let client = TcpStream::connect(addr);

    if let Ok(mut stream) = client.await {
        println!(&quot;created stream&quot;);

        let result = stream.write_all(b&quot;hello world\n&quot;).await;

        println!(&quot;wrote to stream; success={:?}&quot;, result.is_ok());
    }
}
</code></pre></pre>
<p>Notice how <code>main()</code> has become an <code>async</code> function. It is equivalent to placing all its code inside an <code>async</code> block.</p>
<p>If we rewrite this example in full, without the procedural macro:</p>
<pre><pre class="playpen"><code class="language-rust edition2018">use tokio::io::AsyncWriteExt;
use tokio::net::TcpStream;
use tokio::runtime::Runtime;

fn main() {
    let addr = &quot;127.0.0.1:6142&quot;;
    let client = TcpStream::connect(addr);

    let future = async move {
        if let Ok(mut stream) = client.await {
            println!(&quot;created stream&quot;);

            let result = stream.write_all(b&quot;hello world\n&quot;).await;

            println!(&quot;wrote to stream; success={:?}&quot;, result.is_ok());
        }
    };

    let rt = Runtime::new().unwrap();
    println!(&quot;About to create the stream and write to it...&quot;);
    rt.block_on(future);
    println!(&quot;Stream has been created and written to.&quot;);
}
</code></pre></pre>
<p>In this case we create the default runtime, and spawn the task onto it, blocking the current thread until all spawned tasks
have completed and all resources (like files and sockets) have been dropped.</p>
<p>So far, we only have a single task running on the executor, so the <code>client</code> task
is the only one blocking <code>run</code> from returning. Once <code>run</code> has returned we can be sure
that our Future has been run to completion.</p>
<p>You can find the full example <a href="https://github.com/tokio-rs/tokio/blob/master/examples/hello_world.rs">here</a>.</p>
<h1><a class="header" href="#running-the-code" id="running-the-code">Running the code</a></h1>
<p><a href="http://netcat.sourceforge.net/">Netcat</a> is a tool for quickly creating TCP sockets from the command line. The following
command starts a listening TCP socket on the previously specified port.</p>
<pre><code class="language-bash">$ nc -l -p 6142
</code></pre>
<blockquote>
<p>The command above is used with the GNU version of netcat that comes stock on many
unix based operating systems. The following command can be used with the
<a href="https://nmap.org">NMap.org</a> version: <code>$ ncat -l -p 6142</code></p>
</blockquote>
<p>In a different terminal we'll run our project.</p>
<pre><code class="language-bash">$ cargo run
</code></pre>
<p>If everything goes well, you should see <code>hello world</code> printed from Netcat.</p>
<h1><a class="header" href="#next-steps" id="next-steps">Next steps</a></h1>
<p>We've only dipped our toes into Tokio and its asynchronous model. The next page in
the guide will start digging a bit deeper into Futures and the Tokio runtime model.</p>
<h1><a class="header" href="#hello-world-1" id="hello-world-1">Hello World!</a></h1>
<p>To kick off our tour of Tokio, we will start with the obligatory &quot;hello world&quot;
example. This program will create a TCP stream and write &quot;hello, world!&quot; to the stream.
The difference between this and a Rust program that writes to a TCP stream without Tokio
is that this program won't block program execution when the stream is created or when
our &quot;hello, world!&quot; message is written to the stream.</p>
<p>Before we begin you should have a very basic understanding of how TCP streams work. Having
an understanding of Rust’s <a href="https://doc.rust-lang.org/std/net/struct.TcpStream.html">standard library implementation</a>
is also helpful.</p>
<p>Let's get started.</p>
<p>First, generate a new crate.</p>
<pre><code class="language-bash">$ cargo new hello-world
$ cd hello-world
</code></pre>
<p>Next, add the necessary dependencies in <code>Cargo.toml</code>:</p>
<pre><code class="language-toml">[dependencies]
tokio = &quot;0.2.0-alpha&quot;
</code></pre>
<p>We are going to use Tokio's own <a href="https://docs.rs/tokio/*/tokio/net/index.html"><code>net</code></a> module. This module provides the same
abstractions over networking and I/O-operations as the corresponding module in <code>std</code>
with a small difference: all actions are performed asynchronously.</p>
<h1><a class="header" href="#creating-the-stream-1" id="creating-the-stream-1">Creating the stream</a></h1>
<p>The first step is to create the <code>TcpStream</code>. We use the <code>TcpStream</code> implementation
provided by Tokio.</p>
<pre><pre class="playpen"><code class="language-rust edition2018">use tokio::net::TcpStream;

fn main() {
    let addr = &quot;127.0.0.1:6142&quot;;
    let client = TcpStream::connect(addr);

    // Following snippets come here...
}
</code></pre></pre>
<p>Next, we'll add some to the <code>client</code> <code>TcpStream</code>. This asynchronous task now creates
the stream and then yields it once it's been created for additional processing.</p>
<pre><pre class="playpen"><code class="language-rust edition2018"><span class="boring">use tokio::net::TcpStream;
</span>
<span class="boring">fn main() {
</span>let addr = &quot;127.0.0.1:6142&quot;;
let client = TcpStream::connect(addr);

let future = async move {
  // TcpStream::connect future has an Output type of io::Result&lt;TcpStream&gt;
  match client.await {
    Ok(_stream) =&gt; {
      println!(&quot;created stream&quot;);

      // Process stream here.
    }
    Err(err) =&gt; {
      // In our example, we are only going to log the error to STDOUT.
      println!(&quot;connection error = {:?}&quot;, err);
    }
  };
};
<span class="boring">}
</span></code></pre></pre>
<p>The call to <code>TcpStream::connect</code> returns a <a href="https://docs.rs/futures-preview/*/futures-preview/future/trait.Future.html"><code>Future</code></a> of the created TCP stream.
We'll learn more about <a href="getting-started//docs/getting-started/futures/"><code>Futures</code></a> later in the guide, but for now you can think of
a <a href="https://docs.rs/futures-preview/*/futures-preview/future/trait.Future.html"><code>Future</code></a> as a value that represents something that will eventually happen in the
future (in this case the stream will be created). This means that <code>TcpStream::connect</code> does
not wait for the stream to be created before it returns. Rather, it returns immediately
with a value representing the work of creating a TCP stream.</p>
<p>Note the <code>async</code> block that follows. Like the <code>TcpStream::connect</code> future,
the contents of the <code>async</code> block are not executed immediately.
Instead, they are stored in an object whose result can be computed later.
Inside the <code>async</code> block we can <code>await</code> the created future, so that any code that follows
is executed with the result of the <code>await</code>-ed <a href="https://docs.rs/futures-preview/*/futures-preview/future/trait.Future.html"><code>Future</code></a>'s computation.</p>
<p>We will be digging more into futures (and the related concepts of streams and sinks) later on.</p>
<p>Next, we will process the stream.</p>
<h1><a class="header" href="#writing-data-1" id="writing-data-1">Writing data</a></h1>
<p>Our goal is to write <code>&quot;hello world\n&quot;</code> to the stream.</p>
<p>Going back to the <code>async</code> block in the previous example:</p>
<pre><pre class="playpen"><code class="language-rust edition2018">use tokio::io::AsyncWriteExt;
use tokio::net::TcpStream;

fn main() {
    let addr = &quot;127.0.0.1:6142&quot;;
    let client = TcpStream::connect(addr);

    let future = async move {
        if let Ok(mut stream) = client.await {
            println!(&quot;created stream&quot;);

            let result = stream.write_all(b&quot;hello world\n&quot;).await;

            println!(&quot;wrote to stream; success={:?}&quot;, result.is_ok());
        }
    };
}
</code></pre></pre>
<p>The [<code>AsyncWriteExt::write_all</code>] trait method takes <code>stream</code> by mutable reference,
<a href="https://docs.rs/futures-preview/*/futures-preview/future/trait.Future.html"><code>Future</code></a> that completes once the entire message has been written to the
stream. In our example, we <code>await</code> for the completion of said future and just
write a message to <code>STDOUT</code> indicating that the write has completed.</p>
<p>Note that <code>result</code> is a <code>Result</code> that contains the original stream (compare to
<code>and_then</code>, which passes the stream without the <code>Result</code> wrapper). This allows us
to sequence additional reads or writes to the same stream. However, we have
nothing more to do, so we just drop the stream, which automatically closes it.</p>
<h1><a class="header" href="#running-the-client-task-1" id="running-the-client-task-1">Running the client task</a></h1>
<p>So far we have a <code>Future</code> representing the work to be done by our program, but we
have not actually run it. We need a way to 'spawn' that work. We need an executor.</p>
<p>Executors are responsible for scheduling asynchronous tasks, driving them to
completion. There are a number of executor implementations to choose from, each have
different pros and cons. In this example, we will use the default executor of the
<a href="https://docs.rs/tokio/*/tokio/runtime/index.html">Tokio runtime</a>.</p>
<pre><pre class="playpen"><code class="language-rust edition2018">use tokio::io::AsyncWriteExt;
use tokio::net::TcpStream;

#[tokio::main]
async fn main() {
    let addr = &quot;127.0.0.1:6142&quot;;
    let client = TcpStream::connect(addr);

    if let Ok(mut stream) = client.await {
        println!(&quot;created stream&quot;);

        let result = stream.write_all(b&quot;hello world\n&quot;).await;

        println!(&quot;wrote to stream; success={:?}&quot;, result.is_ok());
    }
}
</code></pre></pre>
<p>Notice how <code>main()</code> has become an <code>async</code> function. It is equivalent to placing all its code inside an <code>async</code> block.</p>
<p>If we rewrite this example in full, without the procedural macro:</p>
<pre><pre class="playpen"><code class="language-rust edition2018">use tokio::io::AsyncWriteExt;
use tokio::net::TcpStream;
use tokio::runtime::Runtime;

fn main() {
    let addr = &quot;127.0.0.1:6142&quot;;
    let client = TcpStream::connect(addr);

    let future = async move {
        if let Ok(mut stream) = client.await {
            println!(&quot;created stream&quot;);

            let result = stream.write_all(b&quot;hello world\n&quot;).await;

            println!(&quot;wrote to stream; success={:?}&quot;, result.is_ok());
        }
    };

    let rt = Runtime::new().unwrap();
    println!(&quot;About to create the stream and write to it...&quot;);
    rt.block_on(future);
    println!(&quot;Stream has been created and written to.&quot;);
}
</code></pre></pre>
<p>In this case we create the default runtime, and spawn the task onto it, blocking the current thread until all spawned tasks
have completed and all resources (like files and sockets) have been dropped.</p>
<p>So far, we only have a single task running on the executor, so the <code>client</code> task
is the only one blocking <code>run</code> from returning. Once <code>run</code> has returned we can be sure
that our Future has been run to completion.</p>
<p>You can find the full example <a href="https://github.com/tokio-rs/tokio/blob/master/examples/hello_world.rs">here</a>.</p>
<h1><a class="header" href="#running-the-code-1" id="running-the-code-1">Running the code</a></h1>
<p><a href="http://netcat.sourceforge.net/">Netcat</a> is a tool for quickly creating TCP sockets from the command line. The following
command starts a listening TCP socket on the previously specified port.</p>
<pre><code class="language-bash">$ nc -l -p 6142
</code></pre>
<blockquote>
<p>The command above is used with the GNU version of netcat that comes stock on many
unix based operating systems. The following command can be used with the
<a href="https://nmap.org">NMap.org</a> version: <code>$ ncat -l -p 6142</code></p>
</blockquote>
<p>In a different terminal we'll run our project.</p>
<pre><code class="language-bash">$ cargo run
</code></pre>
<p>If everything goes well, you should see <code>hello world</code> printed from Netcat.</p>
<h1><a class="header" href="#next-steps-1" id="next-steps-1">Next steps</a></h1>
<p>We've only dipped our toes into Tokio and its asynchronous model. The next page in
the guide will start digging a bit deeper into Futures and the Tokio runtime model.</p>
<h1><a class="header" href="#futures" id="futures">Futures</a></h1>
<p>Let's take a closer look at futures. Tokio is built on top of <a href="https://doc.rust-lang.org/std/task"><code>task</code></a> and <a href="https://doc.rust-lang.org/std/future"><code>future</code></a> modules
found in the Rust standard library, as well as on the <a href="https://docs.rs/futures"><code>futures</code></a> crate.
This allows Tokio to interop with other libraries also built on the same foundation.</p>
<p><strong>Note</strong>: This runtime model is very different than async libraries found in
other languages. While, at a high level, APIs can look similar, the way code
gets executed differs.</p>
<p>We'll be taking a closer look at the runtime in the upcoming sections, but a
basic understanding of the runtime is necessary to understand futures. To gain
this understanding, we'll first look at the synchronous model that Rust uses by
default and see how this differs from Tokio's asynchronous model.</p>
<h1><a class="header" href="#synchronous-model" id="synchronous-model">Synchronous Model</a></h1>
<p>First, let's talk briefly about the synchronous (or blocking) model that most of the
Rust <a href="https://doc.rust-lang.org/std">standard library</a> uses.</p>
<pre><pre class="playpen"><code class="language-rust edition2018"><span class="boring">use std::io::prelude::*;
</span><span class="boring">use std::net::TcpStream;
</span><span class="boring">fn dox(mut socket: TcpStream) {
</span>// let socket = ...;
let mut buf = [0; 1024];
let n = socket.read(&amp;mut buf).unwrap();

// Do something with &amp;buf[..n];
<span class="boring">}
</span><span class="boring">fn main() {}
</span></code></pre></pre>
<p>When <code>socket.read</code> is called, either the socket has pending data in its receive
buffer or it does not. If there is pending data, the call to <code>read</code> will return
immediately and <code>buf</code> will be filled with that data. However, if there is no
pending data, the <code>read</code> function will block the current thread until data is
received. Once the data is received, <code>buf</code> will be filled with this newly received
data and the <code>read</code> function will return.</p>
<p>In order to perform reads on many different sockets concurrently, a thread per
socket is required. Using a thread per socket does not scale up very well to
large numbers of sockets. This is known as the <a href="https://en.wikipedia.org/wiki/C10k_problem">c10k</a> problem.</p>
<h1><a class="header" href="#non-blocking-sockets" id="non-blocking-sockets">Non-blocking sockets</a></h1>
<p>The way to avoid blocking a thread when performing an operation like read is to
not block the thread! Non-blocking sockets allow performing operations, like read,
without blocking the thread. When the socket has no pending data in its receive
buffer, the <code>read</code> function returns immediately, indicating that the socket was &quot;not
ready&quot; to perform the read operation.</p>
<p>When using a Tokio <a href="https://docs.rs/tokio/*/tokio/net/struct.TcpStream.html"><code>TcpStream</code></a>, a call to <code>read</code> will always immediately return
a value (<a href="https://doc.rust-lang.org/std/io/enum.ErrorKind.html#variant.WouldBlock"><code>ErrorKind::WouldBlock</code></a>) even if there is no pending data to read.
If there is no pending data, the caller is responsible for calling <code>read</code> again
at a later time.  The trick is to know when that &quot;later time&quot; is.</p>
<p>Another way to think about a non-blocking read is as 'polling' the socket for
data to read.</p>
<p>Futures are an abstraction around this polling model. A <code>Future</code> represents a value
that will be available at &quot;some point in the future&quot;. We can poll the future and
ask if the value is ready or not. Let's take a look in more detail.</p>
<h1><a class="header" href="#a-closer-look-at-futures" id="a-closer-look-at-futures">A closer look at futures</a></h1>
<p>A future is a value that represents the completion of an asynchronous
computation. Usually, the future <em>completes</em> due to an event that happens
elsewhere in the system. While we’ve been looking at things from the perspective
of basic I/O, you can use a future to represent a wide range of events, e.g.:</p>
<ul>
<li>
<p><strong>A database query</strong>, when the query finishes, the future is completed, and
its value is the result of the query.</p>
</li>
<li>
<p><strong>An RPC invocation</strong> to a server. When the server replies, the future is
completed, and its value is the server’s response.</p>
</li>
<li>
<p><strong>A timeout</strong>. When time is up, the future is completed, the value is an empty tuple
<code>()</code> (also referred to as &quot;unit&quot; or &quot;the unit type&quot;).</p>
</li>
<li>
<p><strong>A long-running CPU-intensive task</strong>, running on a thread pool. When the task
finishes, the future is completed, and its value is the return value of the
task.</p>
</li>
<li>
<p><strong>Reading bytes from a socket</strong>. When the bytes are ready, the future is
completed – and depending on the buffering strategy, the bytes might be
returned directly, or written as a side-effect into some existing buffer.</p>
</li>
</ul>
<p>The entire point of the future abstraction is to allow asynchronous functions,
i.e., functions that cannot immediately return a value, to be able to return
<strong>something</strong>.</p>
<p>For example, an asynchronous HTTP client could provide a <code>get</code> function that
looks like this:</p>
<pre><code class="language-rust ignore">pub fn get(&amp;self, uri: &amp;str) -&gt; ResponseFuture { ... }
</code></pre>
<p>Then, the user of the library would use the function as so:</p>
<pre><code class="language-rust ignore">let response_future = client.get(&quot;https://www.example.com&quot;);
</code></pre>
<p>Now, the <code>response_future</code> isn't the actual response. It is a future that will
complete once the response is received. However, since the caller has a concrete
<strong>value</strong> (the future), they can start to use it. For example, they may chain
computations using combinators to perform once the response is received or they
might pass the future to a function.</p>
<pre><code class="language-rust ignore">let response_is_ok = response_future
    .map_ok(|response| {
        response.status().is_ok()
    });

track_response_success(response_is_ok);
</code></pre>
<p>None of those actions taken with the future perform any immediate work.
They cannot because they don't have the actual HTTP response. Instead, they
define the work to be done when the response future completes and the actual
response is available.</p>
<p>Both the <a href="https://docs.rs/futures"><code>futures</code></a> crate and Tokio come with a collection of combinator
functions that can be used to work with futures. So far we've seen <code>and_then</code> which
chains two <a href="https://docs.rs/futures"><code>futures</code></a> together, <code>then</code> which allows to chain a future to a previous
one even if the previous one errored, and <code>map</code> which simply maps a future's value
from one type to another.</p>
<p>We'll be exploring more combinators later in this guide.</p>
<h1><a class="header" href="#poll-based-futures" id="poll-based-futures">Poll based Futures</a></h1>
<p>As hinted at earlier, Rust futures are poll based. This means that instead of a
<code>Future</code> being responsible for pushing the data somewhere once it is complete, it
relies on being asked whether it is complete or not.</p>
<p>This is a unique aspect of the Rust future library. Most future libraries for other
programming languages use a push based model where callbacks are supplied to the
future and the computation invokes the callback immediately with the computation
result.</p>
<p>Using a poll based model offers <a href="https://aturon.github.io/blog/2016/09/07/futures-design/">many advantages</a>, including being a zero cost
abstraction, i.e., using Rust futures has no added overhead compared to writing
the asynchronous code by hand.</p>
<p>We'll take a closer look at this poll based model in the next section.</p>
<h2><a class="header" href="#the-future-trait" id="the-future-trait">The Future trait</a></h2>
<p>The <code>Future</code> trait is as follows:</p>
<pre><code class="language-rust ignore">trait Future {
    /// The type of the value returned when the future completes.
    type Output;

    /// The function that will be repeatedly called to see if the future
    /// has completed or not
    fn poll(self: Pin&lt;&amp;mut Self&gt;, cx: &amp;mut Context) -&gt; Poll&lt;Self::Output&gt;;
}
</code></pre>
<p>For now it's just important to know that futures have an associated type: <code>Output</code>.
This is the type of the value that the <code>Future</code> will yield when it completes.</p>
<p>Additionally, <code>Future</code>s have one method, named <code>poll</code>. We won't go into too much detail
about <code>poll</code> in this section since you don't need to know about <code>poll</code> to use
futures with async/await. The only thing to be aware for now is that <code>poll</code> is
what the runtime will call in order to see if the <code>Future</code> is complete yet or not.
If you're curious: <a href="https://doc.rust-lang.org/std/task/enum.Poll.html"><code>Poll</code></a> is an enum with values <code>Ready(Item)</code> or <code>Pending</code> which
informs the runtime of if the future is complete or not.</p>
<p>In a future section, we'll be implementing a <code>Future</code> from scratch including writing
a poll function that properly informs the runtime when the future is complete.</p>
<h2><a class="header" href="#streams" id="streams">Streams</a></h2>
<p>Streams are the iterator equivalent of futures. Instead of yielding a value at some
point in the future, streams yield a collection of values each at some point in the
future. In other words, streams don't yield just one value at one point in the
future like futures do. They rather keep yielding values over time.</p>
<p>Just like futures, you can use streams to represent a wide range of things as long
as those things produce discrete values at different points sometime in the future.
For instance:</p>
<ul>
<li><strong>UI Events</strong> caused by the user interacting with a GUI in different ways. When an
event happens the stream yields a different message to your app over time.</li>
<li><strong>Push Notifications from a server</strong>. Sometimes a request/response model is not
what you need. A client can establish a notification stream with a server to be
able to receive messages from the server without specifically being requested.</li>
<li><strong>Incoming socket connections</strong>. As different clients connect to a server, the
connections stream will yield socket connections.</li>
</ul>
<p>Streams are very similar to futures in their implementation:</p>
<pre><code class="language-rust ignore">trait Stream {
    /// The type of the value yielded by the stream.
    type Item;

    /// The function that will be repeatedly called to see if the stream has
    /// another value it can yield
    fn poll_next(self: Pin&lt;&amp;mut Self&gt;, cx: &amp;mut Context) -&gt; Poll&lt;Option&lt;Self::Item&gt;&gt;
}
</code></pre>
<p>Streams come with their own set of combinators and will be covered in more depth
in the <strong>Working with futures</strong> section.</p>
<h1><a class="header" href="#runtime" id="runtime">Runtime</a></h1>
<p>In the previous section we explored Futures and Streams which allow us to represent
a value (in the case of a <code>Future</code>) or a series of values (in the case of <code>Stream</code>)
that will be available &quot;at some point in the future&quot;. We talked about <code>poll</code> on
<code>Future</code> and <code>Stream</code> which the runtime will call to figure out if the <code>Future</code> or
the <code>Stream</code> are ready to yield a value.</p>
<p>Lastly, we said that the runtime is needed to poll Futures and Streams driving them
to completion. We'll take a closer look at the runtime now.</p>
<h2><a class="header" href="#tokio-runtime" id="tokio-runtime">Tokio runtime</a></h2>
<p>In order for a <code>Future</code> to make progress, something has to call <code>poll</code>. This is the
job of the runtime.</p>
<p>The runtime is responsible for repeatedly calling <code>poll</code> on a <code>Future</code> until its
value is returned. There are many different ways to do this and thus many types of
runtime configurations. For example, the <a href="https://docs.rs/tokio/*/tokio/runtime/current_thread"><code>CurrentThread</code></a> runtime configuration
will block the current thread and loop through all spawned Futures, calling poll on
them. The thread pool configuration schedules Futures across a thread pool. This
is also the default configuration used by the Tokio [runtime][rt].</p>
<p>It's important to remember that all futures <strong>must</strong> be spawned on the runtime or no
work will be performed.</p>
<h2><a class="header" href="#spawning-tasks" id="spawning-tasks">Spawning Tasks</a></h2>
<p>One of the unique aspects of Tokio is that futures can be spawned on the runtime from
within other futures or streams. When we use futures in this way, we usually refer to
them as tasks. Tasks are the application’s “unit of logic”. They are similar to [Go’s
goroutine] and [Erlang’s process], but asynchronous. In other words, tasks are
asynchronous green threads.</p>
<p>Given that a task runs an asynchronous bit of logic, they are represented by the
Future trait. The task’s future implementation completes with a <code>()</code> value once the
task is done processing.</p>
<p>Tasks are passed to the runtime, which handle scheduling the task. The runtime is
usually scheduling many tasks across a single or small set of threads. Tasks must not
perform computation-heavy logic or they will prevent other tasks from executing. So
don’t try to compute the fibonacci sequence as a task!</p>
<p>Tasks are implemented by either building up a future using the various combinator
functions available in the futures and tokio crates or by implementing the Future
trait directly.</p>
<p>We can spawn tasks using <code>tokio::spawn</code>. For example:</p>
<pre><pre class="playpen"><code class="language-rust edition2018"><span class="boring">use tokio::prelude::*;
</span>
<span class="boring">fn main() {
</span><span class="boring">let mut my_outer_stream = tokio::stream::iter(Some(1));
</span>// Create some kind of future that we want our runtime to execute
let program = async move {
  while let Some(my_outer_value) = my_outer_stream.next().await {
    println!(&quot;Got value {:?} from the stream&quot;, my_outer_value);

    let my_inner_future = tokio::future::ready(1);

    tokio::spawn(async move {
      let my_inner_value = my_inner_future.await;
      println!(&quot;Got a value {:?} from second future&quot;, my_inner_value);
    });
  }
};

tokio::runtime::Runtime::new().unwrap().block_on(program);
<span class="boring">}
</span></code></pre></pre>
<p>Again spawning tasks can happen within other futures or streams allowing multiple
things to happen concurrently. In the above example we're spawning the inner future
from within the outer stream. Each time we get a value from the stream we'll simply
run inner future.</p>
<p>In the next section, we'll take a look at a more involved example than our hello-
world example that takes everything we've learned so far into account.</p>
<p>[rt]: {{&lt; api-url &quot;tokio&quot; &gt;}}/runtime/index.html
[Go’s goroutine]: https://www.golang-book.com/books/intro/10
[Erlang’s process]: http://erlang.org/doc/reference_manual/processes.html</p>
<h1><a class="header" href="#example-an-echo-server" id="example-an-echo-server">Example: An Echo Server</a></h1>
<p>We're going to use what has been covered so far to build an echo server. This is a
Tokio application that incorporates everything we've learned so far. The server will
simply receive messages from the connected client and send back the same message it
received to the client.</p>
<p>We'll be able to test this echo server using the basic Tcp client we created in the
<a href="getting-started/../hello-world">hello world</a> section.</p>
<p>The full code can be found <a href="https://github.com/tokio-rs/tokio/blob/master/examples/echo.rs">here</a>.</p>
<h1><a class="header" href="#setup" id="setup">Setup</a></h1>
<p>First, generate a new crate.</p>
<pre><code class="language-shell">$ cargo new --bin echo-server
cd echo-server
</code></pre>
<p>Next, add the necessary dependencies:</p>
<pre><code class="language-toml">[dependencies]
tokio = &quot;0.2.0-alpha&quot;
futures-preview = &quot;0.3.0-alpha&quot;
</code></pre>
<p>and the crates and types into scope in <code>main.rs</code>:</p>
<pre><code class="language-rust ignore">use tokio::io;
use tokio::net::TcpListener;
use tokio::prelude::*;

<span class="boring">fn main() {}
</span></code></pre>
<p>Now, we setup the necessary structure for a server:</p>
<ul>
<li>Bind a <code>TcpListener</code> to a local port.</li>
<li>Define a task that accepts inbound connections and processes them.</li>
<li>Spawn the server task.</li>
<li>Start the Tokio runtime</li>
</ul>
<p>Again, no work actually happens until the server task is spawned on the
executor.</p>
<pre><pre class="playpen"><code class="language-rust edition2018"><span class="boring">use futures::prelude::*;
</span><span class="boring">use tokio::net::TcpListener;
</span><span class="boring">use tokio::prelude::*;
</span>#[tokio::main]
async fn main() {
    let addr = &quot;127.0.0.1:6142&quot;;
    let listener = TcpListener::bind(addr).await.unwrap();

    // Here we convert the `TcpListener` to a stream of incoming connections
    // with the `incoming` method. We then define how to process each element in
    // the stream with the `for_each` combinator method
    let server = async move {
        let mut incoming = listener.incoming();
        while let Some(socket_res) = incoming.next().await {
            match socket_res {
                Ok(socket) =&gt; {
                    println!(&quot;Accepted connection from {:?}&quot;, socket.peer_addr());
                    // TODO: Process socket
                }
                Err(err) =&gt; {
                    // Handle error by printing to STDOUT.
                    println!(&quot;accept error = {:?}&quot;, err);
                }
            }
        }
    };

    println!(&quot;Server running on localhost:6142&quot;);
<span class="boring">   // `select` completes when the first of the two futures completes. Since
</span><span class="boring">   // future::ready() completes immediately, the server won't hang waiting for
</span><span class="boring">   // more connections. This is just so the doc test doesn't hang.
</span><span class="boring">   let server = future::select(Box::pin(server), future::ready(Ok::&lt;_, ()&gt;(())));
</span>
    // Start the server and block this async fn until `server` spins down.
    server.await;
}
</code></pre></pre>
<p>Here we've created a TcpListener that can listen for incoming TCP connections. On the
listener we call <code>incoming</code> which turns the listener into a <code>Stream</code> of inbound client
connections. We then call <code>for_each</code> which will yield each inbound client connection.
For now we're not doing anything with this inbound connection - that's our next step.</p>
<p>Once we have our server, we <code>.await</code> on it. Up until this point our
server feature has done nothing. It's up to the Tokio runtime to drive our future to
completion.</p>
<h2><a class="header" href="#handling-the-connections" id="handling-the-connections">Handling the connections</a></h2>
<p>Now that we have incoming client connections, we should handle them.</p>
<p>We just want to copy all data read from the socket back onto the socket itself
(e.g. &quot;echo&quot;). We can use the standard <a href="https://docs.rs/tokio/*/tokio/io/trait.AsyncReadExt.html#method.copy"><code>AsyncReadExt::copy</code></a> trait method to do precisely this.</p>
<p>The <code>copy</code> method is called on the source where to read from and takes one argument, where to write to.
We only have one argument, though, with <code>socket</code>. Luckily there's a method, <a href="https://docs.rs/tokio/*/tokio/io/trait.AsyncRead.html#method.split"><code>split</code></a>
, which will split a readable and writeable stream into its two halves. This
operation allows us to work with each stream independently, such as pass them as two
arguments to the <code>copy</code> function.</p>
<p>The <code>copy</code> method then returns a future, and this future will be resolved when the
copying operation is complete, resolving to the amount of data that was copied.</p>
<p>Let's take a look at the connection accept code again.</p>
<pre><pre class="playpen"><code class="language-rust no_run edition2018"><span class="boring">use std::env;
</span><span class="boring">use tokio::prelude::*;
</span><span class="boring">use tokio::net::TcpListener;
</span><span class="boring">#[tokio::main]
</span><span class="boring">async fn main() {
</span><span class="boring">let addr = env::args().nth(1).unwrap_or(&quot;127.0.0.1:8080&quot;.to_string());
</span><span class="boring">// Bind the server's socket.
</span><span class="boring">let mut incoming = TcpListener::bind(&amp;addr)
</span><span class="boring">    .await
</span><span class="boring">    .expect(&quot;unable to bind TCP listener&quot;)
</span><span class="boring">    .incoming();
</span>let server = {
  async move {
    while let Some(conn) = incoming.next().await {
      match conn {
        Err(e) =&gt; eprintln!(&quot;accept failed = {:?}&quot;, e),
        Ok(mut sock) =&gt; {
          // Spawn the future that echos the data and returns how
          // many bytes were copied as a concurrent task.
          tokio::spawn(async move {
            // Split up the reading and writing parts of the
            // socket.
            let (mut reader, mut writer) = sock.split();

            match reader.copy(&amp;mut writer).await {
              Ok(amt) =&gt; {
                println!(&quot;wrote {} bytes&quot;, amt);
              }
              Err(err) =&gt; {
                eprintln!(&quot;IO error {:?}&quot;, err);
              }
            }
          });
        }
      }
    }
  }
};
<span class="boring">server.await
</span><span class="boring">}
</span></code></pre></pre>
<p>As you can see we've split the <code>socket</code> stream into readable and writable parts. We
then used <code>AsyncReadExt::copy</code> to read from <code>reader</code> and write into <code>writer</code>. We <code>await</code> on the result and inspect it printing some diagnostics.</p>
<p>The call to <a href="https://docs.rs/tokio/*/tokio/fn.spawn.html"><code>tokio::spawn</code></a> is the key here. We crucially want all clients to make
progress concurrently, rather than blocking one on completion of another. To achieve
this we use the <code>tokio::spawn</code> function to execute the work in the background.</p>
<p>If we did not do this then each invocation of the block in the loop would be
resolved at a time meaning we could never have two client connections processed
concurrently!</p>
<p>The full code can be found <a href="https://github.com/tokio-rs/tokio/blob/master/examples/echo.rs">here</a>.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                        

                        

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                

                
            </nav>

        </div>

        

        

        
        
        
        <script type="text/javascript">
            window.playpen_copyable = true;
        </script>
        

        

        
        <script src="elasticlunr.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="mark.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="searcher.js" type="text/javascript" charset="utf-8"></script>
        

        <script src="clipboard.min.js" type="text/javascript" charset="utf-8"></script>
        <script src="highlight.js" type="text/javascript" charset="utf-8"></script>
        <script src="book.js" type="text/javascript" charset="utf-8"></script>

        <!-- Custom JS scripts -->
        

        
        
        <script type="text/javascript">
        window.addEventListener('load', function() {
            window.setTimeout(window.print, 100);
        });
        </script>
        
        

    </body>
</html>
